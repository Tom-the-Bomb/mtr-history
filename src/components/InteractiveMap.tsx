import { useEffect, useRef, useState } from 'react'
import * as d3 from 'd3'
import mapRaw from '../assets/map.svg?raw'
import yearMap from '../data/mtr-lines.json'
import stationMap from '../data/mtr-stations.json'
// optional, higher-fidelity per-segment mapping generated by offline split/research
import segmentsMap from '../data/mtr-segments.json'

function clamp(v: number, a: number, b: number) {
    return Math.max(a, Math.min(b, v));
}

export default function InteractiveMap() {
    const containerRef = useRef<HTMLDivElement | null>(null);
    const [year, setYear] = useState<number>(() => {
        const vals = Object.values(yearMap) as number[];
        return Math.min(...vals);
    });

    const [playing, setPlaying] = useState(false)
    const intervalRef = useRef<number | null>(null)

  useEffect(() => {
    // inject raw SVG markup
    if (!containerRef.current) return
    containerRef.current.innerHTML = mapRaw

    const svg = d3.select(containerRef.current).select<SVGSVGElement>('svg')
    // Split multi-segment paths inside #mtr-lines into separate <path> elements
    const splitPathsIntoSegments = () => {
      const group = svg.select('#mtr-lines')
      if (group.empty()) return
      group.selectAll<SVGPathElement, any>('path').each(function () {
        const p = d3.select(this)
        const d = p.attr('d')
        if (!d) return
        // split on new Move commands (M or m) while keeping the command
        const parts = d.split(/(?=[Mm])/).map(s => s.trim()).filter(Boolean)
        if (parts.length <= 1) return // nothing to split

        const origId = p.attr('id') || 'path'
        parts.forEach((segD, idx) => {
          const newId = `${origId}_seg${idx + 1}`
          // append segment path with same class/style attributes
          const newPath = group.append('path').attr('d', segD).attr('id', newId)
          const cls = p.attr('class')
          if (cls) newPath.attr('class', cls)
          const style = p.attr('style')
          if (style) newPath.attr('style', style)
          // copy common presentation attributes if present
          ;['stroke', 'stroke-width', 'fill', 'transform'].forEach(attr => {
            const v = p.attr(attr)
            if (v) newPath.attr(attr, v)
          })
        })

        // remove original combined path so only segments remain
        p.remove()
      })
    }

    splitPathsIntoSegments()

    // Build a combined mapping for segment-level years. If an offline
    // `segmentsMap` exists (higher fidelity), prefer those explicit entries.
    // Otherwise fall back to `yearMap` and the runtime splitting heuristic
    // (baseYear + index) used previously.
    const combinedSegmentMap: Record<string, number> = {}

    // If we have an explicit segments file, use its `year` values directly.
    if (segmentsMap && typeof segmentsMap === 'object') {
      Object.entries(segmentsMap).forEach(([id, objAny]) => {
        // segmentsMap values may be objects like { year, source, note }
        const anyObj: any = objAny
        if (anyObj && (anyObj.year || anyObj.year === 0)) {
          combinedSegmentMap[id] = Number(anyObj.year)
        }
      })
    }

    // For any ids not covered by the offline segments map, fall back to the
    // existing runtime splitting heuristic based on `yearMap`.
    Object.entries(yearMap).forEach(([id, baseYear]) => {
      // if segments already present from segmentsMap, skip
      const already = Object.keys(combinedSegmentMap).some(k => k === id || k.startsWith(id + '_seg'))
      if (already) return

      const segs = svg.selectAll(`#mtr-lines path[id^='${id}_seg']`).nodes()
      if (segs && segs.length > 0) {
        segs.forEach((_, i) => {
          combinedSegmentMap[`${id}_seg${i + 1}`] = baseYear + i
        })
      } else {
        // no split done for this id â€” keep the original mapping
        combinedSegmentMap[id] = baseYear
      }
    })

    // Merge station map (stations are <use> elements); stations keep their years
    Object.entries(stationMap).forEach(([id, y]) => {
      combinedSegmentMap[id] = y
    })

    // now attach data-year and prepare stroke animation
    Object.entries(combinedSegmentMap).forEach(([id, y]) => {
      const el = svg.select(`#${id}`)
      if (el.empty()) return
      const node = el.node() as any
      el.attr('data-year', String(y))

      try {
        if (typeof node.getTotalLength === 'function') {
          const len = node.getTotalLength()
          el.attr('data-length', String(len))
            .attr('stroke-dasharray', String(len))
            .attr('stroke-dashoffset', String(len))
            .style('opacity', '1')
        } else {
          // fallback for non-paths (e.g. station markers): hide initially
          el.style('opacity', '0.15')
        }
      } catch (err) {
        // ignore elements that don't support path length
        el.style('opacity', '0.15')
      }
    })

        const vals = Object.values(combinedSegmentMap) as number[]
        setMinYear(Math.min(...vals))
        setMaxYear(Math.max(...vals))
        setYear((prev) => clamp(prev, Math.min(...vals), Math.max(...vals)))

        // cleanup on unmount
        return () => {
            if (intervalRef.current) {
                window.clearInterval(intervalRef.current)
            }
        }
    }, [])

    useEffect(() => {
        const svg = d3.select(containerRef.current)
            .select<SVGSVGElement>('svg');

        svg.selectAll('[data-year]').each(() => {
            const el = d3.select(this);

            const elYear = Number(el.attr('data-year'))
            const lenAttr = el.attr('data-length')
            const len = lenAttr ? Number(lenAttr) : null

            if (elYear <= year) {
                if (len != null) {
                el.transition().duration(800).attr('stroke-dashoffset', '0').style('opacity', '1')
                } else {
                el.transition().duration(400).style('opacity', '1')
                }
            } else {
                if (len != null) {
                el.transition().duration(600).attr('stroke-dashoffset', String(len)).style('opacity', '0.15')
                } else {
                el.transition().duration(400).style('opacity', '0.15')
                }
            }
        });
    }, [year])

    // useEffect(() => {
    //     if (playing) {
    //         intervalRef.current = window.setInterval(() => {
    //             setYear((y) => {
    //             if (y >= maxYear) {
    //                 setPlaying(false)
    //                 if (intervalRef.current) window.clearInterval(intervalRef.current)
    //                 return y
    //             }
    //             return y + 1
    //             })
    //         }, 700)
    //     } else {
    //     if (intervalRef.current) {
    //         window.clearInterval(intervalRef.current)
    //         intervalRef.current = null
    //     }
    //     }
    //     return () => {
    //     if (intervalRef.current) window.clearInterval(intervalRef.current)
    //     }
    // }, [playing, maxYear])

    return (
        <main className="grow flex flex-col items-center justify-center gap-6">
            <div ref={containerRef} className="grow"/>
            <div className="flex items-center gap-12">
                <button
                    type="button"
                    onClick={() => setPlaying(!playing)}
                >
                    {playing ? 'Pause' : 'Play'}
                </button>
                <div className="gap-5">
                    1910
                    <input
                        type="range"
                        min="1910"
                        max="2025"
                        id="year-range"
                        value={year}
                        onChange={(e) => setYear(Number(e.target.value))}
                        className="w-90"
                    />
                    2025
                </div>
                <label htmlFor="year-range">
                    Year: <strong>{year}</strong>
                </label>
            </div>
        </main>
    )
}
